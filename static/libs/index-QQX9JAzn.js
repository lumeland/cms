import{N as NodeType,q as NodeProp,s as styleTags,t as tags,r as NodeSet,P as Parser,T as Tag,u as Tree,p as parseMixed,g as syntaxTree,n as EditorSelection,v as countColumn,a as LanguageSupport,w as Prec,x as keymap,y as htmlCompletionSource,C as CompletionContext,z as EditorState,A as Language,B as indentUnit,o as html,D as defineLanguageFacet,f as foldNodeProp,b as indentNodeProp,F as languageDataProp,G as foldService,H as LanguageDescription,I as ParseContext}from"./code-jjdEvLco.js";class CompositeBlock{static create(type,value,from,parentHash,end){return new CompositeBlock(type,value,from,parentHash+(parentHash<<8)+type+(value<<4)|0,end,[],[])}constructor(type,value,from,hash,end,children,positions){this.type=type,this.value=value,this.from=from,this.hash=hash,this.end=end,this.children=children,this.positions=positions,this.hashProp=[[NodeProp.contextHash,hash]]}addChild(child,pos){child.prop(NodeProp.contextHash)!=this.hash&&(child=new Tree(child.type,child.children,child.positions,child.length,this.hashProp)),this.children.push(child),this.positions.push(pos)}toTree(nodeSet,end=this.end){let last=this.children.length-1;return last>=0&&(end=Math.max(end,this.positions[last]+this.children[last].length+this.from)),new Tree(nodeSet.types[this.type],this.children,this.positions,end-this.from).balance({makeTree:(children,positions,length)=>new Tree(NodeType.none,children,positions,length,this.hashProp)})}}var Type;!function(Type){Type[Type.Document=1]="Document",Type[Type.CodeBlock=2]="CodeBlock",Type[Type.FencedCode=3]="FencedCode",Type[Type.Blockquote=4]="Blockquote",Type[Type.HorizontalRule=5]="HorizontalRule",Type[Type.BulletList=6]="BulletList",Type[Type.OrderedList=7]="OrderedList",Type[Type.ListItem=8]="ListItem",Type[Type.ATXHeading1=9]="ATXHeading1",Type[Type.ATXHeading2=10]="ATXHeading2",Type[Type.ATXHeading3=11]="ATXHeading3",Type[Type.ATXHeading4=12]="ATXHeading4",Type[Type.ATXHeading5=13]="ATXHeading5",Type[Type.ATXHeading6=14]="ATXHeading6",Type[Type.SetextHeading1=15]="SetextHeading1",Type[Type.SetextHeading2=16]="SetextHeading2",Type[Type.HTMLBlock=17]="HTMLBlock",Type[Type.LinkReference=18]="LinkReference",Type[Type.Paragraph=19]="Paragraph",Type[Type.CommentBlock=20]="CommentBlock",Type[Type.ProcessingInstructionBlock=21]="ProcessingInstructionBlock",Type[Type.Escape=22]="Escape",Type[Type.Entity=23]="Entity",Type[Type.HardBreak=24]="HardBreak",Type[Type.Emphasis=25]="Emphasis",Type[Type.StrongEmphasis=26]="StrongEmphasis",Type[Type.Link=27]="Link",Type[Type.Image=28]="Image",Type[Type.InlineCode=29]="InlineCode",Type[Type.HTMLTag=30]="HTMLTag",Type[Type.Comment=31]="Comment",Type[Type.ProcessingInstruction=32]="ProcessingInstruction",Type[Type.Autolink=33]="Autolink",Type[Type.HeaderMark=34]="HeaderMark",Type[Type.QuoteMark=35]="QuoteMark",Type[Type.ListMark=36]="ListMark",Type[Type.LinkMark=37]="LinkMark",Type[Type.EmphasisMark=38]="EmphasisMark",Type[Type.CodeMark=39]="CodeMark",Type[Type.CodeText=40]="CodeText",Type[Type.CodeInfo=41]="CodeInfo",Type[Type.LinkTitle=42]="LinkTitle",Type[Type.LinkLabel=43]="LinkLabel",Type[Type.URL=44]="URL"}(Type||(Type={}));class LeafBlock{constructor(start,content){this.start=start,this.content=content,this.marks=[],this.parsers=[]}}class Line{constructor(){this.text="",this.baseIndent=0,this.basePos=0,this.depth=0,this.markers=[],this.pos=0,this.indent=0,this.next=-1}forward(){this.basePos>this.pos&&this.forwardInner()}forwardInner(){let newPos=this.skipSpace(this.basePos);this.indent=this.countIndent(newPos,this.pos,this.indent),this.pos=newPos,this.next=newPos==this.text.length?-1:this.text.charCodeAt(newPos)}skipSpace(from){return skipSpace(this.text,from)}reset(text){for(this.text=text,this.baseIndent=this.basePos=this.pos=this.indent=0,this.forwardInner(),this.depth=1;this.markers.length;)this.markers.pop()}moveBase(to){this.basePos=to,this.baseIndent=this.countIndent(to,this.pos,this.indent)}moveBaseColumn(indent){this.baseIndent=indent,this.basePos=this.findColumn(indent)}addMarker(elt){this.markers.push(elt)}countIndent(to,from=0,indent=0){for(let i=from;i<to;i++)indent+=9==this.text.charCodeAt(i)?4-indent%4:1;return indent}findColumn(goal){let i=0;for(let indent=0;i<this.text.length&&indent<goal;i++)indent+=9==this.text.charCodeAt(i)?4-indent%4:1;return i}scrub(){if(!this.baseIndent)return this.text;let result="";for(let i=0;i<this.basePos;i++)result+=" ";return result+this.text.slice(this.basePos)}}function skipForList(bl,cx,line){if(line.pos==line.text.length||bl!=cx.block&&line.indent>=cx.stack[line.depth+1].value+line.baseIndent)return!0;if(line.indent>=line.baseIndent+4)return!1;let size=(bl.type==Type.OrderedList?isOrderedList:isBulletList)(line,cx,!1);return size>0&&(bl.type!=Type.BulletList||isHorizontalRule(line,cx,!1)<0)&&line.text.charCodeAt(line.pos+size-1)==bl.value}const DefaultSkipMarkup={[Type.Blockquote]:(bl,cx,line)=>62==line.next&&(line.markers.push(elt(Type.QuoteMark,cx.lineStart+line.pos,cx.lineStart+line.pos+1)),line.moveBase(line.pos+(space(line.text.charCodeAt(line.pos+1))?2:1)),bl.end=cx.lineStart+line.text.length,!0),[Type.ListItem]:(bl,_cx,line)=>!(line.indent<line.baseIndent+bl.value&&line.next>-1)&&(line.moveBaseColumn(line.baseIndent+bl.value),!0),[Type.OrderedList]:skipForList,[Type.BulletList]:skipForList,[Type.Document]:()=>!0};function space(ch){return 32==ch||9==ch||10==ch||13==ch}function skipSpace(line,i=0){for(;i<line.length&&space(line.charCodeAt(i));)i++;return i}function skipSpaceBack(line,i,to){for(;i>to&&space(line.charCodeAt(i-1));)i--;return i}function isFencedCode(line){if(96!=line.next&&126!=line.next)return-1;let pos=line.pos+1;for(;pos<line.text.length&&line.text.charCodeAt(pos)==line.next;)pos++;if(pos<line.pos+3)return-1;if(96==line.next)for(let i=pos;i<line.text.length;i++)if(96==line.text.charCodeAt(i))return-1;return pos}function isBlockquote(line){return 62!=line.next?-1:32==line.text.charCodeAt(line.pos+1)?2:1}function isHorizontalRule(line,cx,breaking){if(42!=line.next&&45!=line.next&&95!=line.next)return-1;let count=1;for(let pos=line.pos+1;pos<line.text.length;pos++){let ch=line.text.charCodeAt(pos);if(ch==line.next)count++;else if(!space(ch))return-1}return breaking&&45==line.next&&isSetextUnderline(line)>-1&&line.depth==cx.stack.length||count<3?-1:1}function inList(cx,type){for(let i=cx.stack.length-1;i>=0;i--)if(cx.stack[i].type==type)return!0;return!1}function isBulletList(line,cx,breaking){return 45!=line.next&&43!=line.next&&42!=line.next||line.pos!=line.text.length-1&&!space(line.text.charCodeAt(line.pos+1))||!(!breaking||inList(cx,Type.BulletList)||line.skipSpace(line.pos+2)<line.text.length)?-1:1}function isOrderedList(line,cx,breaking){let pos=line.pos,next=line.next;for(;next>=48&&next<=57;){if(pos++,pos==line.text.length)return-1;next=line.text.charCodeAt(pos)}return pos==line.pos||pos>line.pos+9||46!=next&&41!=next||pos<line.text.length-1&&!space(line.text.charCodeAt(pos+1))||breaking&&!inList(cx,Type.OrderedList)&&(line.skipSpace(pos+1)==line.text.length||pos>line.pos+1||49!=line.next)?-1:pos+1-line.pos}function isAtxHeading(line){if(35!=line.next)return-1;let pos=line.pos+1;for(;pos<line.text.length&&35==line.text.charCodeAt(pos);)pos++;if(pos<line.text.length&&32!=line.text.charCodeAt(pos))return-1;let size=pos-line.pos;return size>6?-1:size}function isSetextUnderline(line){if(45!=line.next&&61!=line.next||line.indent>=line.baseIndent+4)return-1;let pos=line.pos+1;for(;pos<line.text.length&&line.text.charCodeAt(pos)==line.next;)pos++;let end=pos;for(;pos<line.text.length&&space(line.text.charCodeAt(pos));)pos++;return pos==line.text.length?end:-1}const EmptyLine=/^[ \t]*$/,CommentEnd=/-->/,ProcessingEnd=/\?>/,HTMLBlockStyle=[[/^<(?:script|pre|style)(?:\s|>|$)/i,/<\/(?:script|pre|style)>/i],[/^\s*<!--/,CommentEnd],[/^\s*<\?/,ProcessingEnd],[/^\s*<![A-Z]/,/>/],[/^\s*<!\[CDATA\[/,/\]\]>/],[/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i,EmptyLine],[/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i,EmptyLine]];function isHTMLBlock(line,_cx,breaking){if(60!=line.next)return-1;let rest=line.text.slice(line.pos);for(let i=0,e=HTMLBlockStyle.length-(breaking?1:0);i<e;i++)if(HTMLBlockStyle[i][0].test(rest))return i;return-1}function getListIndent(line,pos){let indentAfter=line.countIndent(pos,line.pos,line.indent),indented=line.countIndent(line.skipSpace(pos),pos,indentAfter);return indented>=indentAfter+5?indentAfter+1:indented}function addCodeText(marks,from,to){let last=marks.length-1;last>=0&&marks[last].to==from&&marks[last].type==Type.CodeText?marks[last].to=to:marks.push(elt(Type.CodeText,from,to))}const DefaultBlockParsers={LinkReference:void 0,IndentedCode(cx,line){let base=line.baseIndent+4;if(line.indent<base)return!1;let start=line.findColumn(base),from=cx.lineStart+start,to=cx.lineStart+line.text.length,marks=[],pendingMarks=[];for(addCodeText(marks,from,to);cx.nextLine()&&line.depth>=cx.stack.length;)if(line.pos==line.text.length){addCodeText(pendingMarks,cx.lineStart-1,cx.lineStart);for(let m of line.markers)pendingMarks.push(m)}else{if(line.indent<base)break;{if(pendingMarks.length){for(let m of pendingMarks)m.type==Type.CodeText?addCodeText(marks,m.from,m.to):marks.push(m);pendingMarks=[]}addCodeText(marks,cx.lineStart-1,cx.lineStart);for(let m of line.markers)marks.push(m);to=cx.lineStart+line.text.length;let codeStart=cx.lineStart+line.findColumn(line.baseIndent+4);codeStart<to&&addCodeText(marks,codeStart,to)}}return pendingMarks.length&&(pendingMarks=pendingMarks.filter((m=>m.type!=Type.CodeText)),pendingMarks.length&&(line.markers=pendingMarks.concat(line.markers))),cx.addNode(cx.buffer.writeElements(marks,-from).finish(Type.CodeBlock,to-from),from),!0},FencedCode(cx,line){let fenceEnd=isFencedCode(line);if(fenceEnd<0)return!1;let from=cx.lineStart+line.pos,ch=line.next,len=fenceEnd-line.pos,infoFrom=line.skipSpace(fenceEnd),infoTo=skipSpaceBack(line.text,line.text.length,infoFrom),marks=[elt(Type.CodeMark,from,from+len)];infoFrom<infoTo&&marks.push(elt(Type.CodeInfo,cx.lineStart+infoFrom,cx.lineStart+infoTo));for(let first=!0;cx.nextLine()&&line.depth>=cx.stack.length;first=!1){let i=line.pos;if(line.indent-line.baseIndent<4)for(;i<line.text.length&&line.text.charCodeAt(i)==ch;)i++;if(i-line.pos>=len&&line.skipSpace(i)==line.text.length){for(let m of line.markers)marks.push(m);marks.push(elt(Type.CodeMark,cx.lineStart+line.pos,cx.lineStart+i)),cx.nextLine();break}{first||addCodeText(marks,cx.lineStart-1,cx.lineStart);for(let m of line.markers)marks.push(m);let textStart=cx.lineStart+line.basePos,textEnd=cx.lineStart+line.text.length;textStart<textEnd&&addCodeText(marks,textStart,textEnd)}}return cx.addNode(cx.buffer.writeElements(marks,-from).finish(Type.FencedCode,cx.prevLineEnd()-from),from),!0},Blockquote(cx,line){let size=isBlockquote(line);return!(size<0)&&(cx.startContext(Type.Blockquote,line.pos),cx.addNode(Type.QuoteMark,cx.lineStart+line.pos,cx.lineStart+line.pos+1),line.moveBase(line.pos+size),null)},HorizontalRule(cx,line){if(isHorizontalRule(line,cx,!1)<0)return!1;let from=cx.lineStart+line.pos;return cx.nextLine(),cx.addNode(Type.HorizontalRule,from),!0},BulletList(cx,line){let size=isBulletList(line,cx,!1);if(size<0)return!1;cx.block.type!=Type.BulletList&&cx.startContext(Type.BulletList,line.basePos,line.next);let newBase=getListIndent(line,line.pos+1);return cx.startContext(Type.ListItem,line.basePos,newBase-line.baseIndent),cx.addNode(Type.ListMark,cx.lineStart+line.pos,cx.lineStart+line.pos+size),line.moveBaseColumn(newBase),null},OrderedList(cx,line){let size=isOrderedList(line,cx,!1);if(size<0)return!1;cx.block.type!=Type.OrderedList&&cx.startContext(Type.OrderedList,line.basePos,line.text.charCodeAt(line.pos+size-1));let newBase=getListIndent(line,line.pos+size);return cx.startContext(Type.ListItem,line.basePos,newBase-line.baseIndent),cx.addNode(Type.ListMark,cx.lineStart+line.pos,cx.lineStart+line.pos+size),line.moveBaseColumn(newBase),null},ATXHeading(cx,line){let size=isAtxHeading(line);if(size<0)return!1;let off=line.pos,from=cx.lineStart+off,endOfSpace=skipSpaceBack(line.text,line.text.length,off),after=endOfSpace;for(;after>off&&line.text.charCodeAt(after-1)==line.next;)after--;after!=endOfSpace&&after!=off&&space(line.text.charCodeAt(after-1))||(after=line.text.length);let buf=cx.buffer.write(Type.HeaderMark,0,size).writeElements(cx.parser.parseInline(line.text.slice(off+size+1,after),from+size+1),-from);after<line.text.length&&buf.write(Type.HeaderMark,after-off,endOfSpace-off);let node=buf.finish(Type.ATXHeading1-1+size,line.text.length-off);return cx.nextLine(),cx.addNode(node,from),!0},HTMLBlock(cx,line){let type=isHTMLBlock(line,cx,!1);if(type<0)return!1;let from=cx.lineStart+line.pos,end=HTMLBlockStyle[type][1],marks=[],trailing=end!=EmptyLine;for(;!end.test(line.text)&&cx.nextLine();){if(line.depth<cx.stack.length){trailing=!1;break}for(let m of line.markers)marks.push(m)}trailing&&cx.nextLine();let nodeType=end==CommentEnd?Type.CommentBlock:end==ProcessingEnd?Type.ProcessingInstructionBlock:Type.HTMLBlock,to=cx.prevLineEnd();return cx.addNode(cx.buffer.writeElements(marks,-from).finish(nodeType,to-from),from),!0},SetextHeading:void 0};class LinkReferenceParser{constructor(leaf){this.stage=0,this.elts=[],this.pos=0,this.start=leaf.start,this.advance(leaf.content)}nextLine(cx,line,leaf){if(-1==this.stage)return!1;let content=leaf.content+"\n"+line.scrub(),finish=this.advance(content);return finish>-1&&finish<content.length&&this.complete(cx,leaf,finish)}finish(cx,leaf){return(2==this.stage||3==this.stage)&&skipSpace(leaf.content,this.pos)==leaf.content.length&&this.complete(cx,leaf,leaf.content.length)}complete(cx,leaf,len){return cx.addLeafElement(leaf,elt(Type.LinkReference,this.start,this.start+len,this.elts)),!0}nextStage(elt){return elt?(this.pos=elt.to-this.start,this.elts.push(elt),this.stage++,!0):(!1===elt&&(this.stage=-1),!1)}advance(content){for(;;){if(-1==this.stage)return-1;if(0==this.stage){if(!this.nextStage(parseLinkLabel(content,this.pos,this.start,!0)))return-1;if(58!=content.charCodeAt(this.pos))return this.stage=-1;this.elts.push(elt(Type.LinkMark,this.pos+this.start,this.pos+this.start+1)),this.pos++}else{if(1!=this.stage){if(2==this.stage){let skip=skipSpace(content,this.pos),end=0;if(skip>this.pos){let title=parseLinkTitle(content,skip,this.start);if(title){let titleEnd=lineEnd(content,title.to-this.start);titleEnd>0&&(this.nextStage(title),end=titleEnd)}}return end||(end=lineEnd(content,this.pos)),end>0&&end<content.length?end:-1}return lineEnd(content,this.pos)}if(!this.nextStage(parseURL(content,skipSpace(content,this.pos),this.start)))return-1}}}}function lineEnd(text,pos){for(;pos<text.length;pos++){let next=text.charCodeAt(pos);if(10==next)break;if(!space(next))return-1}return pos}class SetextHeadingParser{nextLine(cx,line,leaf){let underline=line.depth<cx.stack.length?-1:isSetextUnderline(line),next=line.next;if(underline<0)return!1;let underlineMark=elt(Type.HeaderMark,cx.lineStart+line.pos,cx.lineStart+underline);return cx.nextLine(),cx.addLeafElement(leaf,elt(61==next?Type.SetextHeading1:Type.SetextHeading2,leaf.start,cx.prevLineEnd(),[...cx.parser.parseInline(leaf.content,leaf.start),underlineMark])),!0}finish(){return!1}}const DefaultLeafBlocks={LinkReference:(_,leaf)=>91==leaf.content.charCodeAt(0)?new LinkReferenceParser(leaf):null,SetextHeading:()=>new SetextHeadingParser},DefaultEndLeaf=[(_,line)=>isAtxHeading(line)>=0,(_,line)=>isFencedCode(line)>=0,(_,line)=>isBlockquote(line)>=0,(p,line)=>isBulletList(line,p,!0)>=0,(p,line)=>isOrderedList(line,p,!0)>=0,(p,line)=>isHorizontalRule(line,p,!0)>=0,(p,line)=>isHTMLBlock(line,p,!0)>=0],scanLineResult={text:"",end:0};class BlockContext{constructor(parser,input,fragments,ranges){this.parser=parser,this.input=input,this.ranges=ranges,this.line=new Line,this.atEnd=!1,this.reusePlaceholders=new Map,this.stoppedAt=null,this.rangeI=0,this.to=ranges[ranges.length-1].to,this.lineStart=this.absoluteLineStart=this.absoluteLineEnd=ranges[0].from,this.block=CompositeBlock.create(Type.Document,0,this.lineStart,0,0),this.stack=[this.block],this.fragments=fragments.length?new FragmentCursor(fragments,input):null,this.readLine()}get parsedPos(){return this.absoluteLineStart}advance(){if(null!=this.stoppedAt&&this.absoluteLineStart>this.stoppedAt)return this.finish();let{line:line}=this;for(;;){for(let markI=0;;){let next=line.depth<this.stack.length?this.stack[this.stack.length-1]:null;for(;markI<line.markers.length&&(!next||line.markers[markI].from<next.end);){let mark=line.markers[markI++];this.addNode(mark.type,mark.from,mark.to)}if(!next)break;this.finishContext()}if(line.pos<line.text.length)break;if(!this.nextLine())return this.finish()}if(this.fragments&&this.reuseFragment(line.basePos))return null;start:for(;;){for(let type of this.parser.blockParsers)if(type){let result=type(this,line);if(0!=result){if(1==result)return null;line.forward();continue start}}break}let leaf=new LeafBlock(this.lineStart+line.pos,line.text.slice(line.pos));for(let parse of this.parser.leafBlockParsers)if(parse){let parser=parse(this,leaf);parser&&leaf.parsers.push(parser)}lines:for(;this.nextLine()&&line.pos!=line.text.length;){if(line.indent<line.baseIndent+4)for(let stop of this.parser.endLeafBlock)if(stop(this,line,leaf))break lines;for(let parser of leaf.parsers)if(parser.nextLine(this,line,leaf))return null;leaf.content+="\n"+line.scrub();for(let m of line.markers)leaf.marks.push(m)}return this.finishLeaf(leaf),null}stopAt(pos){if(null!=this.stoppedAt&&this.stoppedAt<pos)throw new RangeError("Can't move stoppedAt forward");this.stoppedAt=pos}reuseFragment(start){if(!this.fragments.moveTo(this.absoluteLineStart+start,this.absoluteLineStart)||!this.fragments.matches(this.block.hash))return!1;let taken=this.fragments.takeNodes(this);return!!taken&&(this.absoluteLineStart+=taken,this.lineStart=toRelative(this.absoluteLineStart,this.ranges),this.moveRangeI(),this.absoluteLineStart<this.to?(this.lineStart++,this.absoluteLineStart++,this.readLine()):(this.atEnd=!0,this.readLine()),!0)}get depth(){return this.stack.length}parentType(depth=this.depth-1){return this.parser.nodeSet.types[this.stack[depth].type]}nextLine(){return this.lineStart+=this.line.text.length,this.absoluteLineEnd>=this.to?(this.absoluteLineStart=this.absoluteLineEnd,this.atEnd=!0,this.readLine(),!1):(this.lineStart++,this.absoluteLineStart=this.absoluteLineEnd+1,this.moveRangeI(),this.readLine(),!0)}moveRangeI(){for(;this.rangeI<this.ranges.length-1&&this.absoluteLineStart>=this.ranges[this.rangeI].to;)this.rangeI++,this.absoluteLineStart=Math.max(this.absoluteLineStart,this.ranges[this.rangeI].from)}scanLine(start){let r=scanLineResult;if(r.end=start,start>=this.to)r.text="";else if(r.text=this.lineChunkAt(start),r.end+=r.text.length,this.ranges.length>1){let textOffset=this.absoluteLineStart,rangeI=this.rangeI;for(;this.ranges[rangeI].to<r.end;){rangeI++;let nextFrom=this.ranges[rangeI].from,after=this.lineChunkAt(nextFrom);r.end=nextFrom+after.length,r.text=r.text.slice(0,this.ranges[rangeI-1].to-textOffset)+after,textOffset=r.end-r.text.length}}return r}readLine(){let{line:line}=this,{text:text,end:end}=this.scanLine(this.absoluteLineStart);for(this.absoluteLineEnd=end,line.reset(text);line.depth<this.stack.length;line.depth++){let cx=this.stack[line.depth],handler=this.parser.skipContextMarkup[cx.type];if(!handler)throw new Error("Unhandled block context "+Type[cx.type]);if(!handler(cx,this,line))break;line.forward()}}lineChunkAt(pos){let text,next=this.input.chunk(pos);if(this.input.lineChunks)text="\n"==next?"":next;else{let eol=next.indexOf("\n");text=eol<0?next:next.slice(0,eol)}return pos+text.length>this.to?text.slice(0,this.to-pos):text}prevLineEnd(){return this.atEnd?this.lineStart:this.lineStart-1}startContext(type,start,value=0){this.block=CompositeBlock.create(type,value,this.lineStart+start,this.block.hash,this.lineStart+this.line.text.length),this.stack.push(this.block)}startComposite(type,start,value=0){this.startContext(this.parser.getNodeType(type),start,value)}addNode(block,from,to){"number"==typeof block&&(block=new Tree(this.parser.nodeSet.types[block],none,none,(null!=to?to:this.prevLineEnd())-from)),this.block.addChild(block,from-this.block.from)}addElement(elt){this.block.addChild(elt.toTree(this.parser.nodeSet),elt.from-this.block.from)}addLeafElement(leaf,elt){this.addNode(this.buffer.writeElements(injectMarks(elt.children,leaf.marks),-elt.from).finish(elt.type,elt.to-elt.from),elt.from)}finishContext(){let cx=this.stack.pop(),top=this.stack[this.stack.length-1];top.addChild(cx.toTree(this.parser.nodeSet),cx.from-top.from),this.block=top}finish(){for(;this.stack.length>1;)this.finishContext();return this.addGaps(this.block.toTree(this.parser.nodeSet,this.lineStart))}addGaps(tree){return this.ranges.length>1?injectGaps(this.ranges,0,tree.topNode,this.ranges[0].from,this.reusePlaceholders):tree}finishLeaf(leaf){for(let parser of leaf.parsers)if(parser.finish(this,leaf))return;let inline=injectMarks(this.parser.parseInline(leaf.content,leaf.start),leaf.marks);this.addNode(this.buffer.writeElements(inline,-leaf.start).finish(Type.Paragraph,leaf.content.length),leaf.start)}elt(type,from,to,children){return"string"==typeof type?elt(this.parser.getNodeType(type),from,to,children):new TreeElement(type,from)}get buffer(){return new Buffer(this.parser.nodeSet)}}function injectGaps(ranges,rangeI,tree,offset,dummies){let rangeEnd=ranges[rangeI].to,children=[],positions=[],start=tree.from+offset;function movePastNext(upto,inclusive){for(;inclusive?upto>=rangeEnd:upto>rangeEnd;){let size=ranges[rangeI+1].from-rangeEnd;offset+=size,upto+=size,rangeI++,rangeEnd=ranges[rangeI].to}}for(let ch=tree.firstChild;ch;ch=ch.nextSibling){movePastNext(ch.from+offset,!0);let node,from=ch.from+offset,reuse=dummies.get(ch.tree);reuse?node=reuse:ch.to+offset>rangeEnd?(node=injectGaps(ranges,rangeI,ch,offset,dummies),movePastNext(ch.to+offset,!1)):node=ch.toTree(),children.push(node),positions.push(from-start)}return movePastNext(tree.to+offset,!1),new Tree(tree.type,children,positions,tree.to+offset-start,tree.tree?tree.tree.propValues:void 0)}class MarkdownParser extends Parser{constructor(nodeSet,blockParsers,leafBlockParsers,blockNames,endLeafBlock,skipContextMarkup,inlineParsers,inlineNames,wrappers){super(),this.nodeSet=nodeSet,this.blockParsers=blockParsers,this.leafBlockParsers=leafBlockParsers,this.blockNames=blockNames,this.endLeafBlock=endLeafBlock,this.skipContextMarkup=skipContextMarkup,this.inlineParsers=inlineParsers,this.inlineNames=inlineNames,this.wrappers=wrappers,this.nodeTypes=Object.create(null);for(let t of nodeSet.types)this.nodeTypes[t.name]=t.id}createParse(input,fragments,ranges){let parse=new BlockContext(this,input,fragments,ranges);for(let w of this.wrappers)parse=w(parse,input,fragments,ranges);return parse}configure(spec){let config=resolveConfig(spec);if(!config)return this;let{nodeSet:nodeSet,skipContextMarkup:skipContextMarkup}=this,blockParsers=this.blockParsers.slice(),leafBlockParsers=this.leafBlockParsers.slice(),blockNames=this.blockNames.slice(),inlineParsers=this.inlineParsers.slice(),inlineNames=this.inlineNames.slice(),endLeafBlock=this.endLeafBlock.slice(),wrappers=this.wrappers;if(nonEmpty(config.defineNodes)){skipContextMarkup=Object.assign({},skipContextMarkup);let styles,nodeTypes=nodeSet.types.slice();for(let s of config.defineNodes){let{name:name,block:block,composite:composite,style:style}="string"==typeof s?{name:s}:s;if(nodeTypes.some((t=>t.name==name)))continue;composite&&(skipContextMarkup[nodeTypes.length]=(bl,cx,line)=>composite(cx,line,bl.value));let id=nodeTypes.length,group=composite?["Block","BlockContext"]:block?id>=Type.ATXHeading1&&id<=Type.SetextHeading2?["Block","LeafBlock","Heading"]:["Block","LeafBlock"]:void 0;nodeTypes.push(NodeType.define({id:id,name:name,props:group&&[[NodeProp.group,group]]})),style&&(styles||(styles={}),Array.isArray(style)||style instanceof Tag?styles[name]=style:Object.assign(styles,style))}nodeSet=new NodeSet(nodeTypes),styles&&(nodeSet=nodeSet.extend(styleTags(styles)))}if(nonEmpty(config.props)&&(nodeSet=nodeSet.extend(...config.props)),nonEmpty(config.remove))for(let rm of config.remove){let block=this.blockNames.indexOf(rm),inline=this.inlineNames.indexOf(rm);block>-1&&(blockParsers[block]=leafBlockParsers[block]=void 0),inline>-1&&(inlineParsers[inline]=void 0)}if(nonEmpty(config.parseBlock))for(let spec of config.parseBlock){let found=blockNames.indexOf(spec.name);if(found>-1)blockParsers[found]=spec.parse,leafBlockParsers[found]=spec.leaf;else{let pos=spec.before?findName(blockNames,spec.before):spec.after?findName(blockNames,spec.after)+1:blockNames.length-1;blockParsers.splice(pos,0,spec.parse),leafBlockParsers.splice(pos,0,spec.leaf),blockNames.splice(pos,0,spec.name)}spec.endLeaf&&endLeafBlock.push(spec.endLeaf)}if(nonEmpty(config.parseInline))for(let spec of config.parseInline){let found=inlineNames.indexOf(spec.name);if(found>-1)inlineParsers[found]=spec.parse;else{let pos=spec.before?findName(inlineNames,spec.before):spec.after?findName(inlineNames,spec.after)+1:inlineNames.length-1;inlineParsers.splice(pos,0,spec.parse),inlineNames.splice(pos,0,spec.name)}}return config.wrap&&(wrappers=wrappers.concat(config.wrap)),new MarkdownParser(nodeSet,blockParsers,leafBlockParsers,blockNames,endLeafBlock,skipContextMarkup,inlineParsers,inlineNames,wrappers)}getNodeType(name){let found=this.nodeTypes[name];if(null==found)throw new RangeError(`Unknown node type '${name}'`);return found}parseInline(text,offset){let cx=new InlineContext(this,text,offset);outer:for(let pos=offset;pos<cx.end;){let next=cx.char(pos);for(let token of this.inlineParsers)if(token){let result=token(cx,next,pos);if(result>=0){pos=result;continue outer}}pos++}return cx.resolveMarkers(0)}}function nonEmpty(a){return null!=a&&a.length>0}function resolveConfig(spec){if(!Array.isArray(spec))return spec;if(0==spec.length)return null;let conf=resolveConfig(spec[0]);if(1==spec.length)return conf;let rest=resolveConfig(spec.slice(1));if(!rest||!conf)return conf||rest;let conc=(a,b)=>(a||none).concat(b||none),wrapA=conf.wrap,wrapB=rest.wrap;return{props:conc(conf.props,rest.props),defineNodes:conc(conf.defineNodes,rest.defineNodes),parseBlock:conc(conf.parseBlock,rest.parseBlock),parseInline:conc(conf.parseInline,rest.parseInline),remove:conc(conf.remove,rest.remove),wrap:wrapA?wrapB?(inner,input,fragments,ranges)=>wrapA(wrapB(inner,input,fragments,ranges),input,fragments,ranges):wrapA:wrapB}}function findName(names,name){let found=names.indexOf(name);if(found<0)throw new RangeError(`Position specified relative to unknown parser ${name}`);return found}let nodeTypes=[NodeType.none];for(let name,i=1;name=Type[i];i++)nodeTypes[i]=NodeType.define({id:i,name:name,props:i>=Type.Escape?[]:[[NodeProp.group,i in DefaultSkipMarkup?["Block","BlockContext"]:["Block","LeafBlock"]]],top:"Document"==name});const none=[];class Buffer{constructor(nodeSet){this.nodeSet=nodeSet,this.content=[],this.nodes=[]}write(type,from,to,children=0){return this.content.push(type,from,to,4+4*children),this}writeElements(elts,offset=0){for(let e of elts)e.writeTo(this,offset);return this}finish(type,length){return Tree.build({buffer:this.content,nodeSet:this.nodeSet,reused:this.nodes,topID:type,length:length})}}class Element{constructor(type,from,to,children=none){this.type=type,this.from=from,this.to=to,this.children=children}writeTo(buf,offset){let startOff=buf.content.length;buf.writeElements(this.children,offset),buf.content.push(this.type,this.from+offset,this.to+offset,buf.content.length+4-startOff)}toTree(nodeSet){return new Buffer(nodeSet).writeElements(this.children,-this.from).finish(this.type,this.to-this.from)}}class TreeElement{constructor(tree,from){this.tree=tree,this.from=from}get to(){return this.from+this.tree.length}get type(){return this.tree.type.id}get children(){return none}writeTo(buf,offset){buf.nodes.push(this.tree),buf.content.push(buf.nodes.length-1,this.from+offset,this.to+offset,-1)}toTree(){return this.tree}}function elt(type,from,to,children){return new Element(type,from,to,children)}const EmphasisUnderscore={resolve:"Emphasis",mark:"EmphasisMark"},EmphasisAsterisk={resolve:"Emphasis",mark:"EmphasisMark"},LinkStart={},ImageStart={};class InlineDelimiter{constructor(type,from,to,side){this.type=type,this.from=from,this.to=to,this.side=side}}const Escapable="!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";let Punctuation=/[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;try{Punctuation=new RegExp("[\\p{Pc}|\\p{Pd}|\\p{Pe}|\\p{Pf}|\\p{Pi}|\\p{Po}|\\p{Ps}]","u")}catch(_){}const DefaultInline={Escape(cx,next,start){if(92!=next||start==cx.end-1)return-1;let escaped=cx.char(start+1);for(let i=0;i<32;i++)if(Escapable.charCodeAt(i)==escaped)return cx.append(elt(Type.Escape,start,start+2));return-1},Entity(cx,next,start){if(38!=next)return-1;let m=/^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(cx.slice(start+1,start+31));return m?cx.append(elt(Type.Entity,start,start+1+m[0].length)):-1},InlineCode(cx,next,start){if(96!=next||start&&96==cx.char(start-1))return-1;let pos=start+1;for(;pos<cx.end&&96==cx.char(pos);)pos++;let size=pos-start,curSize=0;for(;pos<cx.end;pos++)if(96==cx.char(pos)){if(curSize++,curSize==size&&96!=cx.char(pos+1))return cx.append(elt(Type.InlineCode,start,pos+1,[elt(Type.CodeMark,start,start+size),elt(Type.CodeMark,pos+1-size,pos+1)]))}else curSize=0;return-1},HTMLTag(cx,next,start){if(60!=next||start==cx.end-1)return-1;let after=cx.slice(start+1,cx.end),url=/^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(after);if(url)return cx.append(elt(Type.Autolink,start,start+1+url[0].length,[elt(Type.LinkMark,start,start+1),elt(Type.URL,start+1,start+url[0].length),elt(Type.LinkMark,start+url[0].length,start+1+url[0].length)]));let comment=/^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);if(comment)return cx.append(elt(Type.Comment,start,start+1+comment[0].length));let procInst=/^\?[^]*?\?>/.exec(after);if(procInst)return cx.append(elt(Type.ProcessingInstruction,start,start+1+procInst[0].length));let m=/^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(after);return m?cx.append(elt(Type.HTMLTag,start,start+1+m[0].length)):-1},Emphasis(cx,next,start){if(95!=next&&42!=next)return-1;let pos=start+1;for(;cx.char(pos)==next;)pos++;let before=cx.slice(start-1,start),after=cx.slice(pos,pos+1),pBefore=Punctuation.test(before),pAfter=Punctuation.test(after),sBefore=/\s|^$/.test(before),sAfter=/\s|^$/.test(after),leftFlanking=!sAfter&&(!pAfter||sBefore||pBefore),rightFlanking=!sBefore&&(!pBefore||sAfter||pAfter),canOpen=leftFlanking&&(42==next||!rightFlanking||pBefore),canClose=rightFlanking&&(42==next||!leftFlanking||pAfter);return cx.append(new InlineDelimiter(95==next?EmphasisUnderscore:EmphasisAsterisk,start,pos,(canOpen?1:0)|(canClose?2:0)))},HardBreak(cx,next,start){if(92==next&&10==cx.char(start+1))return cx.append(elt(Type.HardBreak,start,start+2));if(32==next){let pos=start+1;for(;32==cx.char(pos);)pos++;if(10==cx.char(pos)&&pos>=start+2)return cx.append(elt(Type.HardBreak,start,pos+1))}return-1},Link:(cx,next,start)=>91==next?cx.append(new InlineDelimiter(LinkStart,start,start+1,1)):-1,Image:(cx,next,start)=>33==next&&91==cx.char(start+1)?cx.append(new InlineDelimiter(ImageStart,start,start+2,1)):-1,LinkEnd(cx,next,start){if(93!=next)return-1;for(let i=cx.parts.length-1;i>=0;i--){let part=cx.parts[i];if(part instanceof InlineDelimiter&&(part.type==LinkStart||part.type==ImageStart)){if(!part.side||cx.skipSpace(part.to)==start&&!/[(\[]/.test(cx.slice(start+1,start+2)))return cx.parts[i]=null,-1;let content=cx.takeContent(i),link=cx.parts[i]=finishLink(cx,content,part.type==LinkStart?Type.Link:Type.Image,part.from,start+1);if(part.type==LinkStart)for(let j=0;j<i;j++){let p=cx.parts[j];p instanceof InlineDelimiter&&p.type==LinkStart&&(p.side=0)}return link.to}}return-1}};function finishLink(cx,content,type,start,startPos){let{text:text}=cx,next=cx.char(startPos),endPos=startPos;if(content.unshift(elt(Type.LinkMark,start,start+(type==Type.Image?2:1))),content.push(elt(Type.LinkMark,startPos-1,startPos)),40==next){let title,pos=cx.skipSpace(startPos+1),dest=parseURL(text,pos-cx.offset,cx.offset);dest&&(pos=cx.skipSpace(dest.to),pos!=dest.to&&(title=parseLinkTitle(text,pos-cx.offset,cx.offset),title&&(pos=cx.skipSpace(title.to)))),41==cx.char(pos)&&(content.push(elt(Type.LinkMark,startPos,startPos+1)),endPos=pos+1,dest&&content.push(dest),title&&content.push(title),content.push(elt(Type.LinkMark,pos,endPos)))}else if(91==next){let label=parseLinkLabel(text,startPos-cx.offset,cx.offset,!1);label&&(content.push(label),endPos=label.to)}return elt(type,start,endPos,content)}function parseURL(text,start,offset){if(60==text.charCodeAt(start)){for(let pos=start+1;pos<text.length;pos++){let ch=text.charCodeAt(pos);if(62==ch)return elt(Type.URL,start+offset,pos+1+offset);if(60==ch||10==ch)return!1}return null}{let depth=0,pos=start;for(let escaped=!1;pos<text.length;pos++){let ch=text.charCodeAt(pos);if(space(ch))break;if(escaped)escaped=!1;else if(40==ch)depth++;else if(41==ch){if(!depth)break;depth--}else 92==ch&&(escaped=!0)}return pos>start?elt(Type.URL,start+offset,pos+offset):pos==text.length&&null}}function parseLinkTitle(text,start,offset){let next=text.charCodeAt(start);if(39!=next&&34!=next&&40!=next)return!1;let end=40==next?41:next;for(let pos=start+1,escaped=!1;pos<text.length;pos++){let ch=text.charCodeAt(pos);if(escaped)escaped=!1;else{if(ch==end)return elt(Type.LinkTitle,start+offset,pos+1+offset);92==ch&&(escaped=!0)}}return null}function parseLinkLabel(text,start,offset,requireNonWS){for(let escaped=!1,pos=start+1,end=Math.min(text.length,pos+999);pos<end;pos++){let ch=text.charCodeAt(pos);if(escaped)escaped=!1;else{if(93==ch)return!requireNonWS&&elt(Type.LinkLabel,start+offset,pos+1+offset);if(requireNonWS&&!space(ch)&&(requireNonWS=!1),91==ch)return!1;92==ch&&(escaped=!0)}}return null}class InlineContext{constructor(parser,text,offset){this.parser=parser,this.text=text,this.offset=offset,this.parts=[]}char(pos){return pos>=this.end?-1:this.text.charCodeAt(pos-this.offset)}get end(){return this.offset+this.text.length}slice(from,to){return this.text.slice(from-this.offset,to-this.offset)}append(elt){return this.parts.push(elt),elt.to}addDelimiter(type,from,to,open,close){return this.append(new InlineDelimiter(type,from,to,(open?1:0)|(close?2:0)))}addElement(elt){return this.append(elt)}resolveMarkers(from){for(let i=from;i<this.parts.length;i++){let close=this.parts[i];if(!(close instanceof InlineDelimiter&&close.type.resolve&&2&close.side))continue;let open,emp=close.type==EmphasisUnderscore||close.type==EmphasisAsterisk,closeSize=close.to-close.from,j=i-1;for(;j>=from;j--){let part=this.parts[j];if(part instanceof InlineDelimiter&&1&part.side&&part.type==close.type&&!(emp&&(1&close.side||2&part.side)&&(part.to-part.from+closeSize)%3==0&&((part.to-part.from)%3||closeSize%3))){open=part;break}}if(!open)continue;let type=close.type.resolve,content=[],start=open.from,end=close.to;if(emp){let size=Math.min(2,open.to-open.from,closeSize);start=open.to-size,end=close.from+size,type=1==size?"Emphasis":"StrongEmphasis"}open.type.mark&&content.push(this.elt(open.type.mark,start,open.to));for(let k=j+1;k<i;k++)this.parts[k]instanceof Element&&content.push(this.parts[k]),this.parts[k]=null;close.type.mark&&content.push(this.elt(close.type.mark,close.from,end));let element=this.elt(type,start,end,content);this.parts[j]=emp&&open.from!=start?new InlineDelimiter(open.type,open.from,start,open.side):null,(this.parts[i]=emp&&close.to!=end?new InlineDelimiter(close.type,end,close.to,close.side):null)?this.parts.splice(i,0,element):this.parts[i]=element}let result=[];for(let i=from;i<this.parts.length;i++){let part=this.parts[i];part instanceof Element&&result.push(part)}return result}findOpeningDelimiter(type){for(let i=this.parts.length-1;i>=0;i--){let part=this.parts[i];if(part instanceof InlineDelimiter&&part.type==type)return i}return null}takeContent(startIndex){let content=this.resolveMarkers(startIndex);return this.parts.length=startIndex,content}skipSpace(from){return skipSpace(this.text,from-this.offset)+this.offset}elt(type,from,to,children){return"string"==typeof type?elt(this.parser.getNodeType(type),from,to,children):new TreeElement(type,from)}}function injectMarks(elements,marks){if(!marks.length)return elements;if(!elements.length)return marks;let elts=elements.slice(),eI=0;for(let mark of marks){for(;eI<elts.length&&elts[eI].to<mark.to;)eI++;if(eI<elts.length&&elts[eI].from<mark.from){let e=elts[eI];e instanceof Element&&(elts[eI]=new Element(e.type,e.from,e.to,injectMarks(e.children,[mark])))}else elts.splice(eI++,0,mark)}return elts}const NotLast=[Type.CodeBlock,Type.ListItem,Type.OrderedList,Type.BulletList];class FragmentCursor{constructor(fragments,input){this.fragments=fragments,this.input=input,this.i=0,this.fragment=null,this.fragmentEnd=-1,this.cursor=null,fragments.length&&(this.fragment=fragments[this.i++])}nextFragment(){this.fragment=this.i<this.fragments.length?this.fragments[this.i++]:null,this.cursor=null,this.fragmentEnd=-1}moveTo(pos,lineStart){for(;this.fragment&&this.fragment.to<=pos;)this.nextFragment();if(!this.fragment||this.fragment.from>(pos?pos-1:0))return!1;if(this.fragmentEnd<0){let end=this.fragment.to;for(;end>0&&"\n"!=this.input.read(end-1,end);)end--;this.fragmentEnd=end?end-1:0}let c=this.cursor;c||(c=this.cursor=this.fragment.tree.cursor(),c.firstChild());let rPos=pos+this.fragment.offset;for(;c.to<=rPos;)if(!c.parent())return!1;for(;;){if(c.from>=rPos)return this.fragment.from<=lineStart;if(!c.childAfter(rPos))return!1}}matches(hash){let tree=this.cursor.tree;return tree&&tree.prop(NodeProp.contextHash)==hash}takeNodes(cx){let cur=this.cursor,off=this.fragment.offset,fragEnd=this.fragmentEnd-(this.fragment.openEnd?1:0),start=cx.absoluteLineStart,end=start,blockI=cx.block.children.length,prevEnd=end,prevI=blockI;for(;;){if(cur.to-off>fragEnd){if(cur.type.isAnonymous&&cur.firstChild())continue;break}let pos=toRelative(cur.from-off,cx.ranges);if(cur.to-off<=cx.ranges[cx.rangeI].to)cx.addNode(cur.tree,pos);else{let dummy=new Tree(cx.parser.nodeSet.types[Type.Paragraph],[],[],0,cx.block.hashProp);cx.reusePlaceholders.set(dummy,cur.tree),cx.addNode(dummy,pos)}if(cur.type.is("Block")&&(NotLast.indexOf(cur.type.id)<0?(end=cur.to-off,blockI=cx.block.children.length):(end=prevEnd,blockI=prevI,prevEnd=cur.to-off,prevI=cx.block.children.length)),!cur.nextSibling())break}for(;cx.block.children.length>blockI;)cx.block.children.pop(),cx.block.positions.pop();return end-start}}function toRelative(abs,ranges){let pos=abs;for(let i=1;i<ranges.length;i++){let gapFrom=ranges[i-1].to,gapTo=ranges[i].from;gapFrom<abs&&(pos-=gapTo-gapFrom)}return pos}const markdownHighlighting=styleTags({"Blockquote/...":tags.quote,HorizontalRule:tags.contentSeparator,"ATXHeading1/... SetextHeading1/...":tags.heading1,"ATXHeading2/... SetextHeading2/...":tags.heading2,"ATXHeading3/...":tags.heading3,"ATXHeading4/...":tags.heading4,"ATXHeading5/...":tags.heading5,"ATXHeading6/...":tags.heading6,"Comment CommentBlock":tags.comment,Escape:tags.escape,Entity:tags.character,"Emphasis/...":tags.emphasis,"StrongEmphasis/...":tags.strong,"Link/... Image/...":tags.link,"OrderedList/... BulletList/...":tags.list,"BlockQuote/...":tags.quote,"InlineCode CodeText":tags.monospace,"URL Autolink":tags.url,"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark":tags.processingInstruction,"CodeInfo LinkLabel":tags.labelName,LinkTitle:tags.string,Paragraph:tags.content}),parser=new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting),Object.keys(DefaultBlockParsers).map((n=>DefaultBlockParsers[n])),Object.keys(DefaultBlockParsers).map((n=>DefaultLeafBlocks[n])),Object.keys(DefaultBlockParsers),DefaultEndLeaf,DefaultSkipMarkup,Object.keys(DefaultInline).map((n=>DefaultInline[n])),Object.keys(DefaultInline),[]);function leftOverSpace(node,from,to){let ranges=[];for(let n=node.firstChild,pos=from;;n=n.nextSibling){let nextPos=n?n.from:to;if(nextPos>pos&&ranges.push({from:pos,to:nextPos}),!n)break;pos=n.to}return ranges}function parseCode(config){let{codeParser:codeParser,htmlParser:htmlParser}=config,wrap=parseMixed(((node,input)=>{let id=node.type.id;if(!codeParser||id!=Type.CodeBlock&&id!=Type.FencedCode){if(htmlParser&&(id==Type.HTMLBlock||id==Type.HTMLTag))return{parser:htmlParser,overlay:leftOverSpace(node.node,node.from,node.to)}}else{let info="";if(id==Type.FencedCode){let infoNode=node.node.getChild(Type.CodeInfo);infoNode&&(info=input.read(infoNode.from,infoNode.to))}let parser=codeParser(info);if(parser)return{parser:parser,overlay:node=>node.type.id==Type.CodeText}}return null}));return{wrap:wrap}}const StrikethroughDelim={resolve:"Strikethrough",mark:"StrikethroughMark"},Strikethrough={defineNodes:[{name:"Strikethrough",style:{"Strikethrough/...":tags.strikethrough}},{name:"StrikethroughMark",style:tags.processingInstruction}],parseInline:[{name:"Strikethrough",parse(cx,next,pos){if(126!=next||126!=cx.char(pos+1)||126==cx.char(pos+2))return-1;let before=cx.slice(pos-1,pos),after=cx.slice(pos+2,pos+3),sBefore=/\s|^$/.test(before),sAfter=/\s|^$/.test(after),pBefore=Punctuation.test(before),pAfter=Punctuation.test(after);return cx.addDelimiter(StrikethroughDelim,pos,pos+2,!sAfter&&(!pAfter||sBefore||pBefore),!sBefore&&(!pBefore||sAfter||pAfter))},after:"Emphasis"}]};function parseRow(cx,line,startI=0,elts,offset=0){let count=0,first=!0,cellStart=-1,cellEnd=-1,esc=!1,parseCell=()=>{elts.push(cx.elt("TableCell",offset+cellStart,offset+cellEnd,cx.parser.parseInline(line.slice(cellStart,cellEnd),offset+cellStart)))};for(let i=startI;i<line.length;i++){let next=line.charCodeAt(i);124!=next||esc?(esc||32!=next&&9!=next)&&(cellStart<0&&(cellStart=i),cellEnd=i+1):((!first||cellStart>-1)&&count++,first=!1,elts&&(cellStart>-1&&parseCell(),elts.push(cx.elt("TableDelimiter",i+offset,i+offset+1))),cellStart=cellEnd=-1),esc=!esc&&92==next}return cellStart>-1&&(count++,elts&&parseCell()),count}function hasPipe(str,start){for(let i=start;i<str.length;i++){let next=str.charCodeAt(i);if(124==next)return!0;92==next&&i++}return!1}const delimiterLine=/^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;class TableParser{constructor(){this.rows=null}nextLine(cx,line,leaf){if(null==this.rows){let lineText;if(this.rows=!1,(45==line.next||58==line.next||124==line.next)&&delimiterLine.test(lineText=line.text.slice(line.pos))){let firstRow=[];parseRow(cx,leaf.content,0,firstRow,leaf.start)==parseRow(cx,lineText,line.pos)&&(this.rows=[cx.elt("TableHeader",leaf.start,leaf.start+leaf.content.length,firstRow),cx.elt("TableDelimiter",cx.lineStart+line.pos,cx.lineStart+line.text.length)])}}else if(this.rows){let content=[];parseRow(cx,line.text,line.pos,content,cx.lineStart),this.rows.push(cx.elt("TableRow",cx.lineStart+line.pos,cx.lineStart+line.text.length,content))}return!1}finish(cx,leaf){return!!this.rows&&(cx.addLeafElement(leaf,cx.elt("Table",leaf.start,leaf.start+leaf.content.length,this.rows)),!0)}}const Table={defineNodes:[{name:"Table",block:!0},{name:"TableHeader",style:{"TableHeader/...":tags.heading}},"TableRow",{name:"TableCell",style:tags.content},{name:"TableDelimiter",style:tags.processingInstruction}],parseBlock:[{name:"Table",leaf:(_,leaf)=>hasPipe(leaf.content,0)?new TableParser:null,endLeaf(cx,line,leaf){if(leaf.parsers.some((p=>p instanceof TableParser))||!hasPipe(line.text,line.basePos))return!1;let next=cx.scanLine(cx.absoluteLineEnd+1).text;return delimiterLine.test(next)&&parseRow(cx,line.text,line.basePos)==parseRow(cx,next,line.basePos)},before:"SetextHeading"}]};class TaskParser{nextLine(){return!1}finish(cx,leaf){return cx.addLeafElement(leaf,cx.elt("Task",leaf.start,leaf.start+leaf.content.length,[cx.elt("TaskMarker",leaf.start,leaf.start+3),...cx.parser.parseInline(leaf.content.slice(3),leaf.start+3)])),!0}}const TaskList={defineNodes:[{name:"Task",block:!0,style:tags.list},{name:"TaskMarker",style:tags.atom}],parseBlock:[{name:"TaskList",leaf:(cx,leaf)=>/^\[[ xX]\][ \t]/.test(leaf.content)&&"ListItem"==cx.parentType().name?new TaskParser:null,after:"SetextHeading"}]},autolinkRE=/(www\.)|(https?:\/\/)|([\w.+-]+@)|(mailto:|xmpp:)/gy,urlRE=/[\w-]+(\.[\w-]+)+(\/[^\s<]*)?/gy,lastTwoDomainWords=/[\w-]+\.[\w-]+($|\/)/,emailRE=/[\w.+-]+@[\w-]+(\.[\w.-]+)+/gy,xmppResourceRE=/\/[a-zA-Z\d@.]+/gy;function count(str,from,to,ch){let result=0;for(let i=from;i<to;i++)str[i]==ch&&result++;return result}function autolinkURLEnd(text,from){urlRE.lastIndex=from;let m=urlRE.exec(text);if(!m||lastTwoDomainWords.exec(m[0])[0].indexOf("_")>-1)return-1;let end=from+m[0].length;for(;;){let m,last=text[end-1];if(/[?!.,:*_~]/.test(last)||")"==last&&count(text,from,end,")")>count(text,from,end,"("))end--;else{if(";"!=last||!(m=/&(?:#\d+|#x[a-f\d]+|\w+);$/.exec(text.slice(from,end))))break;end=from+m.index}}return end}function autolinkEmailEnd(text,from){emailRE.lastIndex=from;let m=emailRE.exec(text);if(!m)return-1;let last=m[0][m[0].length-1];return"_"==last||"-"==last?-1:from+m[0].length-("."==last?1:0)}const Autolink={parseInline:[{name:"Autolink",parse(cx,next,absPos){let pos=absPos-cx.offset;autolinkRE.lastIndex=pos;let m=autolinkRE.exec(cx.text),end=-1;return m?(m[1]||m[2]?end=autolinkURLEnd(cx.text,pos+m[0].length):m[3]?end=autolinkEmailEnd(cx.text,pos):(end=autolinkEmailEnd(cx.text,pos+m[0].length),end>-1&&"xmpp:"==m[0]&&(xmppResourceRE.lastIndex=end,m=xmppResourceRE.exec(cx.text),m&&(end=m.index+m[0].length))),end<0?-1:(cx.addElement(cx.elt("URL",absPos,end+cx.offset)),end+cx.offset)):-1}}]},GFM=[Table,TaskList,Strikethrough,Autolink];function parseSubSuper(ch,node,mark){return(cx,next,pos)=>{if(next!=ch||cx.char(pos+1)==ch)return-1;let elts=[cx.elt(mark,pos,pos+1)];for(let i=pos+1;i<cx.end;i++){let next=cx.char(i);if(next==ch)return cx.addElement(cx.elt(node,pos,i+1,elts.concat(cx.elt(mark,i,i+1))));if(92==next&&elts.push(cx.elt("Escape",i,2+i++)),space(next))break}return-1}}const Superscript={defineNodes:[{name:"Superscript",style:tags.special(tags.content)},{name:"SuperscriptMark",style:tags.processingInstruction}],parseInline:[{name:"Superscript",parse:parseSubSuper(94,"Superscript","SuperscriptMark")}]},Subscript={defineNodes:[{name:"Subscript",style:tags.special(tags.content)},{name:"SubscriptMark",style:tags.processingInstruction}],parseInline:[{name:"Subscript",parse:parseSubSuper(126,"Subscript","SubscriptMark")}]},Emoji={defineNodes:[{name:"Emoji",style:tags.character}],parseInline:[{name:"Emoji",parse(cx,next,pos){let match;return 58==next&&(match=/^[a-zA-Z_0-9]+:/.exec(cx.slice(pos+1,cx.end)))?cx.addElement(cx.elt("Emoji",pos,pos+1+match[0].length)):-1}}]},data=defineLanguageFacet({commentTokens:{block:{open:"\x3c!--",close:"--\x3e"}}}),headingProp=new NodeProp,commonmark=parser.configure({props:[foldNodeProp.add((type=>!type.is("Block")||type.is("Document")||null!=isHeading(type)?void 0:(tree,state)=>({from:state.doc.lineAt(tree.from).to,to:tree.to}))),headingProp.add(isHeading),indentNodeProp.add({Document:()=>null}),languageDataProp.add({Document:data})]});function isHeading(type){let match=/^(?:ATX|Setext)Heading(\d)$/.exec(type.name);return match?+match[1]:void 0}function findSectionEnd(headerNode,level){let last=headerNode;for(;;){let heading,next=last.nextSibling;if(!next||null!=(heading=isHeading(next.type))&&heading<=level)break;last=next}return last.to}const headerIndent=foldService.of(((state,start,end)=>{for(let node=syntaxTree(state).resolveInner(end,-1);node&&!(node.from<start);node=node.parent){let heading=node.type.prop(headingProp);if(null==heading)continue;let upto=findSectionEnd(node,heading);if(upto>end)return{from:end,to:upto}}return null}));function mkLang(parser){return new Language(data,parser,[headerIndent],"markdown")}const commonmarkLanguage=mkLang(commonmark),extended=commonmark.configure([GFM,Subscript,Superscript,Emoji,{props:[foldNodeProp.add({Table:(tree,state)=>({from:state.doc.lineAt(tree.from).to,to:tree.to})})]}]),markdownLanguage=mkLang(extended);function getCodeParser(languages,defaultLanguage){return info=>{if(info&&languages){let found=null;if(info=/\S*/.exec(info)[0],found="function"==typeof languages?languages(info):LanguageDescription.matchLanguageName(languages,info,!0),found instanceof LanguageDescription)return found.support?found.support.language.parser:ParseContext.getSkippingParser(found.load());if(found)return found.parser}return defaultLanguage?defaultLanguage.parser:null}}class Context{constructor(node,from,to,spaceBefore,spaceAfter,type,item){this.node=node,this.from=from,this.to=to,this.spaceBefore=spaceBefore,this.spaceAfter=spaceAfter,this.type=type,this.item=item}blank(maxWidth,trailing=!0){let result=this.spaceBefore+("Blockquote"==this.node.name?">":"");if(null!=maxWidth){for(;result.length<maxWidth;)result+=" ";return result}for(let i=this.to-this.from-result.length-this.spaceAfter.length;i>0;i--)result+=" ";return result+(trailing?this.spaceAfter:"")}marker(doc,add){let number="OrderedList"==this.node.name?String(+itemNumber(this.item,doc)[2]+add):"";return this.spaceBefore+number+this.type+this.spaceAfter}}function getContext(node,doc){let nodes=[];for(let cur=node;cur&&"Document"!=cur.name;cur=cur.parent)"ListItem"!=cur.name&&"Blockquote"!=cur.name&&"FencedCode"!=cur.name||nodes.push(cur);let context=[];for(let i=nodes.length-1;i>=0;i--){let match,node=nodes[i],line=doc.lineAt(node.from),startPos=node.from-line.from;if("FencedCode"==node.name)context.push(new Context(node,startPos,startPos,"","","",null));else if("Blockquote"==node.name&&(match=/^ *>( ?)/.exec(line.text.slice(startPos))))context.push(new Context(node,startPos,startPos+match[0].length,"",match[1],">",null));else if("ListItem"==node.name&&"OrderedList"==node.parent.name&&(match=/^( *)\d+([.)])( *)/.exec(line.text.slice(startPos)))){let after=match[3],len=match[0].length;after.length>=4&&(after=after.slice(0,after.length-4),len-=4),context.push(new Context(node.parent,startPos,startPos+len,match[1],after,match[2],node))}else if("ListItem"==node.name&&"BulletList"==node.parent.name&&(match=/^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(line.text.slice(startPos)))){let after=match[4],len=match[0].length;after.length>4&&(after=after.slice(0,after.length-4),len-=4);let type=match[2];match[3]&&(type+=match[3].replace(/[xX]/," ")),context.push(new Context(node.parent,startPos,startPos+len,match[1],after,type,node))}}return context}function itemNumber(item,doc){return/^(\s*)(\d+)(?=[.)])/.exec(doc.sliceString(item.from,item.from+10))}function renumberList(after,doc,changes,offset=0){for(let prev=-1,node=after;;){if("ListItem"==node.name){let m=itemNumber(node,doc),number=+m[2];if(prev>=0){if(number!=prev+1)return;changes.push({from:node.from+m[1].length,to:node.from+m[0].length,insert:String(prev+2+offset)})}prev=number}let next=node.nextSibling;if(!next)break;node=next}}function normalizeIndent(content,state){let blank=/^[ \t]*/.exec(content)[0].length;if(!blank||"\t"!=state.facet(indentUnit))return content;let space="";for(let i=countColumn(content,4,blank);i>0;)i>=4?(space+="\t",i-=4):(space+=" ",i--);return space+content.slice(blank)}const insertNewlineContinueMarkup=({state:state,dispatch:dispatch})=>{let tree=syntaxTree(state),{doc:doc}=state,dont=null,changes=state.changeByRange((range=>{if(!range.empty||!markdownLanguage.isActiveAt(state,range.from))return dont={range:range};let pos=range.from,line=doc.lineAt(pos),context=getContext(tree.resolveInner(pos,-1),doc);for(;context.length&&context[context.length-1].from>pos-line.from;)context.pop();if(!context.length)return dont={range:range};let inner=context[context.length-1];if(inner.to-inner.spaceAfter.length>pos-line.from)return dont={range:range};let emptyLine=pos>=inner.to-inner.spaceAfter.length&&!/\S/.test(line.text.slice(inner.to));if(inner.item&&emptyLine){if(inner.node.firstChild.to>=pos||line.from>0&&!/[^\s>]/.test(doc.lineAt(line.from-1).text)){let delTo,next=context.length>1?context[context.length-2]:null,insert="";next&&next.item?(delTo=line.from+next.from,insert=next.marker(doc,1)):delTo=line.from+(next?next.to:0);let changes=[{from:delTo,to:pos,insert:insert}];return"OrderedList"==inner.node.name&&renumberList(inner.item,doc,changes,-2),next&&"OrderedList"==next.node.name&&renumberList(next.item,doc,changes),{range:EditorSelection.cursor(delTo+insert.length),changes:changes}}{let insert="";for(let i=0,e=context.length-2;i<=e;i++)insert+=context[i].blank(i<e?countColumn(line.text,4,context[i+1].from)-insert.length:null,i<e);return insert=normalizeIndent(insert,state),{range:EditorSelection.cursor(pos+insert.length+1),changes:{from:line.from,insert:insert+state.lineBreak}}}}if("Blockquote"==inner.node.name&&emptyLine&&line.from){let prevLine=doc.lineAt(line.from-1),quoted=/>\s*$/.exec(prevLine.text);if(quoted&&quoted.index==inner.from){let changes=state.changes([{from:prevLine.from+quoted.index,to:prevLine.to},{from:line.from+inner.from,to:line.to}]);return{range:range.map(changes),changes:changes}}}let changes=[];"OrderedList"==inner.node.name&&renumberList(inner.item,doc,changes);let continued=inner.item&&inner.item.from<line.from,insert="";if(!continued||/^[\s\d.)\-+*>]*/.exec(line.text)[0].length>=inner.to)for(let i=0,e=context.length-1;i<=e;i++)insert+=i!=e||continued?context[i].blank(i<e?countColumn(line.text,4,context[i+1].from)-insert.length:null):context[i].marker(doc,1);let from=pos;for(;from>line.from&&/\s/.test(line.text.charAt(from-line.from-1));)from--;return insert=normalizeIndent(insert,state),changes.push({from:from,to:pos,insert:state.lineBreak+insert}),{range:EditorSelection.cursor(from+insert.length+1),changes:changes}}));return!dont&&(dispatch(state.update(changes,{scrollIntoView:!0,userEvent:"input"})),!0)};function isMark(node){return"QuoteMark"==node.name||"ListMark"==node.name}function contextNodeForDelete(tree,pos){let node=tree.resolveInner(pos,-1),scan=pos;isMark(node)&&(scan=node.from,node=node.parent);for(let prev;prev=node.childBefore(scan);)if(isMark(prev))scan=prev.from;else{if("OrderedList"!=prev.name&&"BulletList"!=prev.name)break;node=prev.lastChild,scan=node.to}return node}const deleteMarkupBackward=({state:state,dispatch:dispatch})=>{let tree=syntaxTree(state),dont=null,changes=state.changeByRange((range=>{let pos=range.from,{doc:doc}=state;if(range.empty&&markdownLanguage.isActiveAt(state,range.from)){let line=doc.lineAt(pos),context=getContext(contextNodeForDelete(tree,pos),doc);if(context.length){let inner=context[context.length-1],spaceEnd=inner.to-inner.spaceAfter.length+(inner.spaceAfter?1:0);if(pos-line.from>spaceEnd&&!/\S/.test(line.text.slice(spaceEnd,pos-line.from)))return{range:EditorSelection.cursor(line.from+spaceEnd),changes:{from:line.from+spaceEnd,to:pos}};if(pos-line.from==spaceEnd&&(!inner.item||line.from<=inner.item.from||!/\S/.test(line.text.slice(0,inner.to)))){let start=line.from+inner.from;if(inner.item&&inner.node.from<inner.item.from&&/\S/.test(line.text.slice(inner.from,inner.to))){let insert=inner.blank(countColumn(line.text,4,inner.to)-countColumn(line.text,4,inner.from));return start==line.from&&(insert=normalizeIndent(insert,state)),{range:EditorSelection.cursor(start+insert.length),changes:{from:start,to:line.from+inner.to,insert:insert}}}if(start<pos)return{range:EditorSelection.cursor(start),changes:{from:start,to:pos}}}}}return dont={range:range}}));return!dont&&(dispatch(state.update(changes,{scrollIntoView:!0,userEvent:"delete"})),!0)},markdownKeymap=[{key:"Enter",run:insertNewlineContinueMarkup},{key:"Backspace",run:deleteMarkupBackward}],htmlNoMatch=html({matchClosingTags:!1});function markdown(config={}){let{codeLanguages:codeLanguages,defaultCodeLanguage:defaultCodeLanguage,addKeymap:addKeymap=!0,base:{parser:parser}=commonmarkLanguage,completeHTMLTags:completeHTMLTags=!0}=config;if(!(parser instanceof MarkdownParser))throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");let defaultCode,extensions=config.extensions?[config.extensions]:[],support=[htmlNoMatch.support];defaultCodeLanguage instanceof LanguageSupport?(support.push(defaultCodeLanguage.support),defaultCode=defaultCodeLanguage.language):defaultCodeLanguage&&(defaultCode=defaultCodeLanguage);let codeParser=codeLanguages||defaultCode?getCodeParser(codeLanguages,defaultCode):void 0;extensions.push(parseCode({codeParser:codeParser,htmlParser:htmlNoMatch.language.parser})),addKeymap&&support.push(Prec.high(keymap.of(markdownKeymap)));let lang=mkLang(parser.configure(extensions));return completeHTMLTags&&support.push(lang.data.of({autocomplete:htmlTagCompletion})),new LanguageSupport(lang,support)}function htmlTagCompletion(context){let{state:state,pos:pos}=context,m=/<[:\-\.\w\u00b7-\uffff]*$/.exec(state.sliceDoc(pos-25,pos));if(!m)return null;let tree=syntaxTree(state).resolveInner(pos,-1);for(;tree&&!tree.type.isTop;){if("CodeBlock"==tree.name||"FencedCode"==tree.name||"ProcessingInstructionBlock"==tree.name||"CommentBlock"==tree.name||"Link"==tree.name||"Image"==tree.name)return null;tree=tree.parent}return{from:pos-m[0].length,to:pos,options:htmlTagCompletions(),validFor:/^<[:\-\.\w\u00b7-\uffff]*$/}}let _tagCompletions=null;function htmlTagCompletions(){if(_tagCompletions)return _tagCompletions;let result=htmlCompletionSource(new CompletionContext(EditorState.create({extensions:htmlNoMatch}),0,!0));return _tagCompletions=result?result.options:[]}export{commonmarkLanguage,deleteMarkupBackward,insertNewlineContinueMarkup,markdown,markdownKeymap,markdownLanguage};